package de.uniba.rz.app;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import methods.Sharedmethods;
import methods.gRPCmethods;
import de.uniba.rz.entities.Priority;
import de.uniba.rz.entities.Status;
import de.uniba.rz.entities.Ticket;
import de.uniba.rz.entities.TicketException;
import de.uniba.rz.entities.Type;
import de.uniba.rz.io.rpc.gRPCindex;
import de.uniba.rz.io.rpc.gRPCstatus;
import de.uniba.rz.io.rpc.gRPCstatus.tstatus;
import de.uniba.rz.io.rpc.gRPCticket;
import de.uniba.rz.io.rpc.gRPCticketlist;
import de.uniba.rz.io.rpc.gRPCupdateReq;
import de.uniba.rz.io.rpc.gRPCticket.ticketpriority;
import de.uniba.rz.io.rpc.gRPCticket.tickettype;
import de.uniba.rz.io.rpc.TicketServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;

public class gRPCTicketManagementBackend implements TicketManagementBackend {
	HashMap<Integer, Ticket> serverTicketStore = new HashMap<>();
	AtomicInteger nextId;
	gRPCticketlist asynclist = null;
	private final String LOGFILE = "clientlogfile.log";
	int port;
	String host;
	TicketClient client;

	/**
	 * Azar: This client shows an interaction with a gRPC server. It calls a method
	 * stub synchronously and asynchronously and shows the unary interaction
	 * mechanism. All related files (service interface plus message classes) are
	 * generated by the protobuf gradle plugin.
	 *
	 * Group J, 2020
	 */
	public class TicketClient {

		/**
		 * "A gRPC channel provides a connection to a gRPC server on a specified host
		 * and port and is used when creating a client stub. Clients can specify channel
		 * arguments to modify gRPC’s default behavior, such as switching on and off
		 * message compression. A channel has state, including connected and idle."
		 */
		private ManagedChannel channel;

		/**
		 * "On the client side, the client has a local object known as stub that
		 * implements the same methods as the service. Client can then just call those
		 * methods on the local object, wrapping the parameters for the call in the
		 * appropriate protocol buffer message type - gRPC looks after sending the
		 * request(s) to the server and returning the server’s protocol buffer
		 * response(s)."
		 */

		/**
		 * "Synchronous RPC calls that block until a response arrives from the server
		 * are the closest approximation to the abstraction of a procedure call that RPC
		 * aspires to."
		 */

		private TicketServiceGrpc.TicketServiceBlockingStub syncTicketStub;
		private TicketServiceGrpc.TicketServiceStub asyncTicketStub;

		public TicketClient(String host, int port) {

			this(ManagedChannelBuilder.forAddress(host, port).usePlaintext());
		}

		public TicketClient(ManagedChannelBuilder<?> channelBuilder) {
			this.channel = channelBuilder.build();

			// stubs are generated by the "protoc" tool ( during the gradle build)
			this.syncTicketStub = TicketServiceGrpc.newBlockingStub(this.channel);
			this.asyncTicketStub = TicketServiceGrpc.newStub(this.channel);
		}

		/**
		 * Updates ticket status to 'ACCEPTED', 'REJECTED' or 'CLOSED' using sync gRPC
		 */

		public void updateTicketSync(int ticketid, Status newstatus) {
			try {
				// converts Ticket Status type to grpc status type
				tstatus newtstatu = new gRPCmethods().gRPCStatus(newstatus);
				gRPCupdateReq request = gRPCupdateReq.newBuilder().setIndex(ticketid)
						.setNewstatus(gRPCstatus.newBuilder().setTicketstatus(newtstatu).build()).build();
				// send sync request to server for update
				this.syncTicketStub.updateTicketStatus(request);

			} catch (StatusRuntimeException e) {
				System.err.println(" [Client]: Error sending new Ticket. See log file: " + LOGFILE);
				String msg = "gRPC Client Runtime Exception\n";
				msg = msg + e.getCause().getMessage();
				new Sharedmethods().log(LOGFILE, msg);
				this.shutdown();
			}
		}

		/**
		 * Sends newly created ticket to server. Server will assign ticket id and store
		 * ticket in its store.
		 */
		public void sendTicketSync(Ticket newTicket) {
			try {
				/* Convert Ticket enum valus (Priority, Status, Type) to grpc ticket types */
				methods.gRPCmethods m = new gRPCmethods();
				ticketpriority newpriority = m.gRPCPriority(newTicket.getPriority());
				tickettype newtype = m.gRPCType(newTicket.getType());
				tstatus newstatus = m.gRPCStatus(newTicket.getStatus());
				gRPCstatus newgstatus = gRPCstatus.newBuilder().setTicketstatus(newstatus).build();

				/* Create a gRPCticket request */
				gRPCticket request = gRPCticket.newBuilder().setId(newTicket.getId())// id
						.setReporter(newTicket.getReporter())// reporter
						.setTopic(newTicket.getTopic())// topic
						.setDescription(newTicket.getDescription())// Description
						.setType(newtype)// type
						.setPriority(newpriority)// priority
						.setTstatus(newgstatus)// status
						.build();

				boolean result = this.syncTicketStub.addTicket(request).getTicketAck();
				if (!result) {
					System.err.println("[CLIENT]: Error updating Ticket #" + String.valueOf(newTicket.getId()));
				}

			} catch (StatusRuntimeException e) {
				System.err.println("[CLIENT]: Error updating Ticket #" + String.valueOf(newTicket.getId())
						+ ". See log file:" + LOGFILE);
				String msg = "gRPC Client Runtime Exception\n";
				msg = msg + e.getCause().getMessage();
				new Sharedmethods().log(LOGFILE, msg);
				this.shutdown();
			}
		}

		public void getTicketsAsync() {
			try {

				int i = -1;
				gRPCindex index = gRPCindex.newBuilder().setIndex(i).build();
				StreamObserver<gRPCticketlist> myobserver = new StreamObserver<gRPCticketlist>() {
					@Override
					public void onError(Throwable t) {

						io.grpc.Status status = io.grpc.Status.fromThrowable(t);
						System.err.println("Azar: Async failed: " + status);
						shutdown();
					}

					@Override
					public void onNext(gRPCticketlist value) {

						// ReadAllTickets();
						// this.a
						// System.out.println("Azar Async: "+String.valueOf(res));
					}

					@Override
					public void onCompleted() {
						System.out.println(
								"The server send all the necessary information. Communication completed successfully.");
					}
				};
				this.asyncTicketStub.getTicket(index, myobserver);

				System.out.println();

			} catch (StatusRuntimeException e) {
				System.err.println("[CLIENT]: The server is unresponsive.");
				String msg = "gRPC Client Runtime Exception\n";
				msg = msg + e.getCause().getMessage();
				new Sharedmethods().log(LOGFILE, msg);
				this.shutdown();
			}

		}

		/**
		 * sends a request to server to get all tickets in server store.
		 */
		public gRPCticketlist getTicketsSync() {
			try {

				int i = -1;
				gRPCindex index = gRPCindex.newBuilder().setIndex(i).build();

				gRPCticketlist response = this.syncTicketStub.getTicket(index);

				return response;

			} catch (StatusRuntimeException e) {
				System.err.println("[CLIENT]: Error in get Ticket client. See log file:" + LOGFILE);
				String msg = "gRPC Client Runtime Exception\n";
				msg = msg + e.getCause().getMessage();
				new Sharedmethods().log(LOGFILE, msg);
				this.shutdown();
				return null;
			}
		}

		public void shutdown() {
			if (!channel.isShutdown()) {
				System.out.println("Trying to shut down the client . . .");
				while (true) {
					try {

						client.shutdown();
						channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
						System.out.println("Client successfully shutdown!");
					} catch (InterruptedException e) {
						String msg = "gRPC Client Interrupted Exception\n";
						msg = msg + e.getMessage();
						new Sharedmethods().log(LOGFILE, msg);

					}
					break;
				}
			}
		}

	}

	public gRPCTicketManagementBackend(String host, int port) {
		nextId = new AtomicInteger(1);// Start Ticket numbers from 1
		client = new TicketClient(host, port);
		this.port = port;
		this.host = host;
	}

	@Override
	public void triggerShutdown() {
		// local implementation is in memory only - no need to close connections
		// and free resources
	}

	@Override
	public Ticket createNewTicket(String reporter, String topic, String description, Type type, Priority priority) {
		Ticket newTicket = new Ticket(nextId.getAndIncrement(), reporter, topic, description, type, priority);

		try {
			client.sendTicketSync(newTicket);
			System.out.println("[CLIENT]: Ticket #" + String.valueOf(newTicket.getId() + " Sent"));
			System.out.println("-------------------------------------------------------------");
		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);
			client.shutdown();
		}
		return (Ticket) newTicket.clone();
	}

	public void ReadAllTicketsAsync() {
		serverTicketStore.clear();
		// TicketClient client = new TicketClient(host, port);
		try {
			client.getTicketsAsync();
			for (int i = 0; i < asynclist.getGRPCticketlisElementCount(); i++) {
				methods.gRPCmethods methods = new gRPCmethods();

				Ticket ticket = methods.gRPCTicketToTicket(asynclist.getGRPCticketlisElement(i));
				serverTicketStore.put(ticket.getId(), ticket);
			} // for

		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);

			client.shutdown();
		}
	}

	public void ReadAllTickets() {
		// TicketClient client = new TicketClient(host, port);
		serverTicketStore.clear();

		try {
			gRPCticketlist tickets = client.getTicketsSync();
			// client.getTicketsAsync();
			for (int i = 0; i < tickets.getGRPCticketlisElementCount(); i++) {
				methods.gRPCmethods methods = new gRPCmethods();

				Ticket ticket = methods.gRPCTicketToTicket(tickets.getGRPCticketlisElement(i));
				serverTicketStore.put(ticket.getId(), ticket);
				System.out.println(" Ticket #" +  String.valueOf(ticket.getId()) + " fetched");
			} // for
			System.out.println("-------------------------------------------------------------");

		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);

			client.shutdown();
		}
	}

	@Override
	public List<Ticket> getAllTickets() throws TicketException {

		ReadAllTickets();
		return serverTicketStore.entrySet().stream().map(entry -> (Ticket) entry.getValue().clone())
				.collect(Collectors.toList());
	}

	@Override
	public Ticket getTicketById(int id) throws TicketException {
		if (!serverTicketStore.containsKey(id)) {
			throw new TicketException("Ticket ID is unknown");
		}

		return (Ticket) getTicketByIdInteral(id).clone();
	}

	private Ticket getTicketByIdInteral(int id) throws TicketException {
		if (!serverTicketStore.containsKey(id)) {
			throw new TicketException("Ticket ID is unknown");
		}
		return serverTicketStore.get(id);
	}

	@Override
	public Ticket acceptTicket(int id) throws TicketException {

		Ticket ticketToModify = getTicketByIdInteral(id);
		if (ticketToModify.getStatus() != Status.NEW) {
			throw new TicketException(
					"Can not accept Ticket as it is currently in status " + ticketToModify.getStatus());
		}

		ticketToModify.setStatus(Status.ACCEPTED);
		// TicketClient client = new TicketClient(host, port);
		try {
			client.updateTicketSync(id, ticketToModify.getStatus());
		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);

			client.shutdown();
		}
		return (Ticket) ticketToModify.clone();
	}

	@Override
	public Ticket rejectTicket(int id) throws TicketException {
		Ticket ticketToModify = getTicketByIdInteral(id);
		if (ticketToModify.getStatus() != Status.NEW) {
			throw new TicketException(
					"Can not reject Ticket as it is currently in status " + ticketToModify.getStatus());
		}

		ticketToModify.setStatus(Status.REJECTED);
		// TicketClient client = new TicketClient(host, port);
		try {

			client.updateTicketSync(id, ticketToModify.getStatus());

		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);

			client.shutdown();
		}

		return (Ticket) ticketToModify.clone();
	}

	@Override
	public Ticket closeTicket(int id) throws TicketException {

		Ticket ticketToModify = getTicketByIdInteral(id);
		if (ticketToModify.getStatus() != Status.ACCEPTED) {
			throw new TicketException(
					"Can not close Ticket as it is currently in status " + ticketToModify.getStatus());
		}

		ticketToModify.setStatus(Status.CLOSED);
		// TicketClient client = new TicketClient(host, port);
		try {

			client.updateTicketSync(id, ticketToModify.getStatus());

		} catch (Exception e) {
			String msg = "gRPC Client Exception\n";
			msg = msg + e.getMessage();
			new Sharedmethods().log(LOGFILE, msg);

			client.shutdown();
		}
		return (Ticket) ticketToModify.clone();
	}

}
